<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Block Blast - MINH HAI DEVELOPER</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #4861d1;
      color: white;
      text-align: center;
      padding: 20px;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(8, 40px);
      grid-template-rows: repeat(8, 40px);
      gap: 2px;
      margin: 0 auto 20px;
      justify-content: center;
    }

    .cell {
      width: 40px;
      height: 40px;
      border: 1px solid #444;
      background-color: #a5d13d42;
      box-sizing: border-box;
      transition: background-color 0.3s;
    }

    .cell.filled {
      background-color: limegreen;
    }

    .cell.highlight {
      background-color: gold !important;
      animation: flash 0.5s ease-in-out;
    }

    @keyframes flash {
      0% { background-color: gold; }
      50% { background-color: orange; }
      100% { background-color: gold; }
    }

    #block-options {
      display: flex;
      gap: 20px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .block {
      display: grid;
      gap: 2px;
      padding: 5px;
      background: #eee;
      border: 2px solid transparent;
      cursor: pointer;
      width: fit-content;
      grid-template-columns: repeat(3, 1fr);
    }

    .block.selected {
      border-color: orange;
      background: #fff8e1;
    }

    .block-cell {
      width: 20px;
      height: 20px;
      background-color: transparent;
      border-radius: 3px;
    }

    .block-cell.filled {
      background-color: steelblue;
    }

    button {
      font-size: 120%;
      background: #a17474;
      color: white;
      border: none;
      padding: 8px 16px;
      cursor: pointer;
    }

    #game-over {
      font-size: 24px;
      color: red;
      display: none;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1 style="color: cyan;">Block Blast</h1>
  <H1 style="color: #a17474; font-style: italic;">MINH HAI DEVELOPER</H1>
  <div id="board"></div>
  <div id="block-options"></div>
  <h3>Score: <span id="score">0</span></h3>
  <div id="game-over">Game Over!</div>
  <button onclick="restartGame()">Restart</button>

  <script>
    const board = document.getElementById("board");
    const blockOptions = document.getElementById("block-options");
    let selectedBlock = null;
    const gridSize = 8;
    let grid = new Array(gridSize * gridSize).fill(0);
    let score = 0;
    let isGameOver = false;

    const blockTemplates = [
      [[1,1,0],[1,1,0],[0,0,0]],
      [[1,1,1],[0,0,0],[0,0,0]],
      [[1,0,0],[1,0,0],[1,0,0]],
      [[0,1,0],[1,1,1],[0,0,0]],
      [[1,1,1],[1,0,0],[0,0,0]],
      [[0,1,1],[1,1,0],[0,0,0]],
    ];

    let blocks = [];

    function renderBoard() {
      board.innerHTML = "";
      for (let i = 0; i < gridSize * gridSize; i++) {
        const cell = document.createElement("div");
        cell.dataset.index = i;
        cell.classList.add("cell");
        if (grid[i] === 1) cell.classList.add("filled");
        cell.addEventListener("click", () => handleBoardClick(i));
        board.appendChild(cell);
      }
    }

    function drawBlockOptions() {
      blockOptions.innerHTML = "";
      blocks.forEach((blockMatrix, i) => {
        const block = document.createElement("div");
        block.classList.add("block");
        block.dataset.blockId = i;
        if (selectedBlock === i) block.classList.add("selected");

        blockMatrix.flat().forEach(value => {
          const cell = document.createElement("div");
          cell.classList.add("block-cell");
          if (value === 1) {
            cell.classList.add("filled");
          } else {
            cell.style.visibility = "hidden";
          }
          block.appendChild(cell);
        });

        block.addEventListener("click", () => {
          selectedBlock = i;
          drawBlockOptions();
        });

        blockOptions.appendChild(block);
      });
    }

    function generateRandomBlocks() {
      blocks.length = 0;
      for (let i = 0; i < 3; i++) {
        const randIndex = Math.floor(Math.random() * blockTemplates.length);
        const clone = blockTemplates[randIndex].map(row => [...row]);
        blocks.push(clone);
      }
    }

    function handleBoardClick(index) {
      if (selectedBlock === null) return;

      const row = Math.floor(index / gridSize);
      const col = index % gridSize;
      const block = blocks[selectedBlock];

      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const value = block[i][j];
          if (value === 0) continue;
          const r = row + i;
          const c = col + j;
          if (r >= gridSize || c >= gridSize) return;
          const idx = r * gridSize + c;
          if (grid[idx] === 1) return;
        }
      }

      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const value = block[i][j];
          if (value === 0) continue;
          const r = row + i;
          const c = col + j;
          const idx = r * gridSize + c;
          grid[idx] = 1;
        }
      }

      clearFullLines();
      updateScoreDisplay();
      blocks.splice(selectedBlock, 1);
      selectedBlock = null;

      if (blocks.length === 0) {
        generateRandomBlocks();
      }

      renderBoard();
      drawBlockOptions();

      if (!canPlaceAnyBlock()) {
        isGameOver = true;
        setTimeout(() => {
          document.getElementById("game-over").style.display = "block";
        }, 100);
      }
    }

    function clearFullLines() {
      let rowsToClear = [];
      let colsToClear = [];

      for (let r = 0; r < gridSize; r++) {
        if (grid.slice(r * gridSize, (r + 1) * gridSize).every(cell => cell === 1)) {
          rowsToClear.push(r);
        }
      }

      for (let c = 0; c < gridSize; c++) {
        let full = true;
        for (let r = 0; r < gridSize; r++) {
          if (grid[r * gridSize + c] === 0) {
            full = false;
            break;
          }
        }
        if (full) colsToClear.push(c);
      }

      rowsToClear.forEach(r => {
        for (let c = 0; c < gridSize; c++) {
          const cell = board.children[r * gridSize + c];
          if (cell) cell.classList.add("highlight");
        }
      });

      colsToClear.forEach(c => {
        for (let r = 0; r < gridSize; r++) {
          const cell = board.children[r * gridSize + c];
          if (cell) cell.classList.add("highlight");
        }
      });

      if (rowsToClear.length > 0 || colsToClear.length > 0) {
        setTimeout(() => {
          rowsToClear.forEach(r => {
            for (let c = 0; c < gridSize; c++) {
              grid[r * gridSize + c] = 0;
            }
          });
          colsToClear.forEach(c => {
            for (let r = 0; r < gridSize; r++) {
              grid[r * gridSize + c] = 0;
            }
          });
          score += (rowsToClear.length + colsToClear.length) * 10;
          renderBoard();
          updateScoreDisplay();
        }, 500);
      }
    }

    function canPlaceAnyBlock() {
      for (let b = 0; b < blocks.length; b++) {
        const block = blocks[b];
        for (let r = 0; r <= gridSize - 3; r++) {
          for (let c = 0; c <= gridSize - 3; c++) {
            if (canPlaceBlockAt(block, r, c)) return true;
          }
        }
      }
      return false;
    }

    function canPlaceBlockAt(block, row, col) {
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          if (block[i][j] === 0) continue;
          const r = row + i;
          const c = col + j;
          if (r >= gridSize || c >= gridSize) return false;
          if (grid[r * gridSize + c] === 1) return false;
        }
      }
      return true;
    }

    function restartGame() {
      grid = new Array(gridSize * gridSize).fill(0);
      score = 0;
      isGameOver = false;
      document.getElementById("game-over").style.display = "none";
      generateRandomBlocks();
      renderBoard();
      drawBlockOptions();
      updateScoreDisplay();
    }

    function updateScoreDisplay() {
      document.getElementById("score").textContent = score;
    }

    generateRandomBlocks();
    renderBoard();
    drawBlockOptions();
    updateScoreDisplay();
  </script>
</body>
</html>
